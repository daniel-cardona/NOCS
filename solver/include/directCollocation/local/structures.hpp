/*
 *
 * Copyright (C) 2020
 * Daniel Cardona-Ortiz <daniel.cardona@cinvestav.edu.mx>, Gustavo Arechavaleta <garechav@cinvestav.edu.mx>
 * CINVESTAV - Saltillo Campus
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef CORE_STRUCTURES
#define CORE_STRUCTURES

#include "Eigen/Dense"
#include "Eigen/Sparse"


typedef Eigen::Triplet<double,int> T;

using namespace std;


//------------ Lower and upper structures ---------------

struct ulb_str{

    Eigen::VectorXd lower;
    Eigen::VectorXd upper;

};

typedef struct ulb_str ulbounds;

//----------- Variable and constraint bounds -------------

struct bnd_str{

    ulbounds states;
    ulbounds controls;
    ulbounds initialTime;
    ulbounds finalTime;
    ulbounds events;
    ulbounds path;
};

typedef struct bnd_str Bounds;


//------------ Guess structures -----------------------


struct guess_str{

    Eigen::MatrixXd states;
    Eigen::MatrixXd controls;
    double t0;
    double tF;

    Eigen::VectorXd x0;
};

typedef guess_str Guess;

//------------ Sparsity structures --------------------

struct str_sparsity{

    Eigen::SparseMatrix<double> A;

    Eigen::SparseMatrix<double> B;


    int nnz_J;             //Number of non-zero elements in the Jacobian 
    Eigen::MatrixXd nzG_J; //Tuple with the sparsity information of the Jacobian

    int nnz_D;             //Number of non-zero elements in the Derivative matrix 
    Eigen::MatrixXd nzG_D; //Tuple with the sparsity information of the Derivative matrix

    Eigen::MatrixXd idxGroupsD;     //Index groups of the derivative matrix
    Eigen::VectorXd sizeGroupsD;    //Size of the index groups

    Eigen::MatrixXd positivePerturbationMatrix;
    Eigen::MatrixXd negativePerturbationMatrix;

    Eigen::MatrixXd dxPattern;
    Eigen::MatrixXd pathPattern;
    Eigen::MatrixXd eventPattern_t0;
    Eigen::MatrixXd eventPattern_tF;
    Eigen::MatrixXd eventPattern_e0;
    Eigen::MatrixXd eventPattern_eF;

    int nnz_Dfk; //Number of non-zero elements in the derivative matrix of the dynamics

    int nnz_Dpk; //Number of non-zero elements in the derivative matrix of the path constraints

    int nnz_De0; //Number of non-zero elements in the derivative matrix of the initial event contraints
    int nnz_DeF; //Number of non-zero elements in the derivative matrix of the final event constaints

    int nnz_Dt0; //Number of non-zero elements in the derivative matrix of the initial time event constraints
    int nnz_DtF; //Number of non-zero elements in the derivative matrix of the final time event constraints

};


//-----------NLP structure --------------------------

struct nlp_str{


    int nDecVar;            //Number of decision variables generated by the transcription process
    int nCns;               //Number of constraints generated by the transcription process
    int nCollocationCns;    //Number of collocation constraints
    int nSegments;          //Number of segments given by the discretization method selected by the user

    Eigen::VectorXd x0;     //Initial guess vector for the NLP Problem
    Eigen::VectorXd xlb;    //Lower bound of the decision variables
    Eigen::VectorXd xub;    //Upper bound of the decision variables

    Eigen::VectorXd glb;    //Lower bounds of the NLP constraints
    Eigen::VectorXd gub;    //Upper bounds of the NLP constraints

    str_sparsity sparsity;  //Sparsity information of the NLP

    Eigen::MatrixXd colPointsRef; //Test variable to store the points per each segment (Useful for high order col methods)

    Eigen::VectorXd xk1;    //Variable that can be used for storage of the k+1 states variables
    Eigen::VectorXd gradxk1; //TEST VARIABLE
    int gradient_eval;      //TEST VARIABLE


    Eigen::VectorXd weights; //Vector that contains the quadrature weights of the collocation methods
    double time_weights;     //Quadrature weigths for the time variables

};

//*********************************************************************
//********************* Mesh variables ********************************
//*********************************************************************

struct meshInfo{

    Eigen::VectorXd tauV;
    Eigen::VectorXd tauV_old;
    Eigen::VectorXd deltaTau;

    Eigen::VectorXd time;

    int nIter;

    Eigen::VectorXd epsilon;
    Eigen::VectorXd epsilon_old;
    Eigen::MatrixXd eta;
    Eigen::VectorXd w;
    Eigen::VectorXd r; //Order reduction vector
    Eigen::VectorXd I;
    Eigen::VectorXd I_old; //Old discretization information

    int p; //Order of the collocation method

    double epsilon_mean;
    double epsilon_max;
    double epsilon_max_history;

};

struct sol{

    Eigen::VectorXd z_opt;

    double t0;
    double tF;

    Eigen::MatrixXd xSol;
    Eigen::MatrixXd uSol;
    Eigen::MatrixXd fSol;
    Eigen::VectorXd tSol;

};


struct alg{

    bool usingExternalLibrary;
    bool meshRefinement;
    bool derivativeChecker;

    double kappa;    //Variable for the predicted error tolerance
    double error_ode; //Variable for error tolarance in the ode
    double maxPoints; //Maximun number of points to be added per segment
    int maxMeshIterations;

};

struct deriv{

    string gradientCost;
    string jacobianCns;

};

struct stats{

    //Cost function stats

    int f_cnt=0;  //Number of calls
    double f_avg_t; //Avg computation time
    double f_tt=0.0;    //Total time

    //Gradient cost function stats

    int fgrad_cnt=0;  //Number of calls
    double fgrad_avg_t; //Avg computation time
    double fgrad_tt=0.0;    //Total time


    //Constraints vector

    int g_cnt=0;  //Number of calls
    double g_avg_t; //Avg computation time
    double g_tt;    //Total time

    //Jacobian of the constraints

    int g_jac_cnt=0;  //Number of calls
    double g_jac_avg_t; //Avg computation time
    double g_jac_tt;    //Total time

};


#endif //End CORE_STRUCTURES




