/*
 *
 * Copyright (C) 2020
 * Daniel Cardona-Ortiz <daniel.cardona@cinvestav.edu.mx>, Gustavo Arechavaleta <garechav@cinvestav.edu.mx>
 * CINVESTAV - Saltillo Campus
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:

 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef LOCAL_COL_MODULE
#define LOCAL_COL_MODULE


#include "core/problem.hpp"
#include "structures.hpp"

#include <nocsConfig.h>


#ifdef pinocchio_compile
    #include "pinocchio/parsers/urdf.hpp"
    #include "pinocchio/algorithm/joint-configuration.hpp"
    #include "pinocchio/algorithm/aba-derivatives.hpp"
    #include "pinocchio/algorithm/centroidal.hpp"
    #include "pinocchio/algorithm/centroidal-derivatives.hpp"


    typedef pinocchio::Data::Matrix6x Matrix6x;
#endif

#ifdef rbdl_compile

    #include "rbdl.h"
    #include "rbdl_utils.h"
    #include "addons/urdfreader/urdfreader.h"

#endif

using namespace std;



namespace nocs {

//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
//&------------------- LOCAL COLLOCATION CLASS-------------------&
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


class localCollocation: public Problem
{
public:


    Bounds bounds;    //Bounds information

    Guess guess;      //Guess information

    nlp_str NLP;

    meshInfo mesh;  //Mesh information

    sol solution; //Solution information

    alg algorithm;

    deriv derivatives; //First-order computation method

    std::string robotFile; //Direction to the urdf (if any)


    //------  Pointer to the robots generated by the dynamic libraries --------

    #ifdef geoMBD_compile

        //geoMBD_crtp pointer
        std::optional<std::shared_ptr<Robot>> robotGeo;
        std::shared_ptr< geoCRTP::FwdDynCRTP <DataType> > robotDynamics;
        std::shared_ptr< geo::FwdDynDifCRTP< DataType > > robotDDynamics;

    #endif


    #ifdef pinocchio_compile
        //pinocchio library objects
        pinocchio::Model model;
        pinocchio::Data robot_data;
    #endif

    #ifdef rbdl_compile
        //rbdl library objects
        RigidBodyDynamics::Model* robot_model;
    #endif



    //------  Pointer to the main function in the generator --------  (The functions depend on the collocation method)

    double (*costFunction)(localCollocation &problem, Eigen::VectorXd &z);
    void   (*gradientCost)(localCollocation &problem, Eigen::VectorXd &z, Eigen::VectorXd &grad);
    void   (*cnsFunction)(localCollocation &problem, Eigen::VectorXd &z, Eigen::VectorXd &c);
    void   (*cnsJacobian)(localCollocation &problem,Eigen::VectorXd &z, Eigen::VectorXd &nzvalues);
    void   (*interpolateSolution)(Eigen::VectorXd &x_t, Eigen::VectorXd &u_t,Eigen::VectorXd &f_t, double &t, localCollocation &problem);


    //------  Pointer to the dynamics and the gradients (The functions depend on the dynamic library and the computation method of the jacobian)

    void (*dynamics)(const Eigen::VectorXd &states, const Eigen::VectorXd &controls,const double &tk, Eigen::VectorXd &derivatives, localCollocation &problem);
    void (*fJacobian)(const Eigen::VectorXd &states, const Eigen::VectorXd &controls,double &t, Eigen::MatrixXd &gradient, localCollocation &problem);
    void (*pathJacobian)(Eigen::VectorXd &states, Eigen::VectorXd &controls,double &t,Eigen::MatrixXd &gradient, localCollocation &problem);
    void (*eventJacobian)(Eigen::VectorXd &x0,Eigen::VectorXd &xN,double &t0,double &tF,Eigen::VectorXd &Dt0, Eigen::VectorXd &DtF,Eigen::MatrixXd &De0, Eigen::MatrixXd &DeF, localCollocation &problem);

    //-----------------------------------------------
    // Constructors and Destructor
    //-----------------------------------------------

    //!Default constructor
    localCollocation(){};

    //! Custom constructor. Initializes the local collocation problem given the main dimension of the problem.
    /*! \param number of states.*/
    /*! \param number of controls.*/
    /*! \param number of discrete points.*/
    /*! \param number of path constraints.*/
    /*! \param number of event constraints.*/

    localCollocation(const int &nStates,const int &nControls,
                     const int &nDiscrete,const int &nPath,const int &nEvents);

    //! GeoMBD constructor. Initializes the local collocation problem given the main dimension of the problem and creates the robot object.
    /*! \param number of states.*/
    /*! \param number of controls.*/
    /*! \param number of discrete points.*/
    /*! \param number of path constraints.*/
    /*! \param number of event constraints.*/
    /*! \param URDF file location.*/

    localCollocation(const int &nStates,const int &nControls,
                     const int &nDiscrete,const int &nPath,const int &nEvents,
                     const std::string & robotFile);


    //! Copy constructor. Initializes the local collocation problem given the information of another object of the same class.
    /*! \param localCollocation object.*/

    localCollocation(const localCollocation &);

    //!Parameterized constructor. Set an object of the localCollocation type using main structures of another object of the the same class.
    //! \param NLP structure
    //! \param bound structure
    //! \param mesh structure
    //! \param collocation method
    //! \param type of derivatives

    localCollocation(const nlp_str &, const meshInfo &, const bnd_str & ,const alg &,
                     const guess_str &, const string &, const deriv &,
                     const std::string & robotFile);

    //-----------------------------------------------
    // Members
    //-----------------------------------------------

    //! Setup the main variables of the non linear problem given the transcription.
    /*! \return void */

    void setupNLP();

    //! Print the basic information of the optimal control problem.
    /*! \return void */

    void printInformation();

    //! Transcribe the optimal control problem to a NLP
    /*! \return void */

    void transcription();

    //! Transcribe the variable bounds of the optimal control problem
    /*! \return void */

    void setVariableBounds();

    //! Transcribe the constraints bounds of the optimal control problem
    /*! \return void */

    void setCnsBounds();

    //! Transcribe the given initial solution
    /*! \return void */

    void setInitialSolution();


    //! Use the last solution to set up a warm start for the next iteration
    //!  \return void
    void setWarmStart();

    //! Detect the sparsity of the whole NLP problem
    /*! \return void */

    void detectProblemSparsity();

    //! Generate the constant matrices A and B. See [Betts,2010] (DEPRECATED (Just for reference) )
    /*! \return void */

    void setConstantMatrices();

    //! Generate the constant matrices A and B. See [Betts,2010] (New version)
    /*! \return void */

    void setConstantAB();

    //! Obtain the spasity patterns of each of the functions
    /*! \return void */

    void obtainBlockPatterns();

    //! Detect the sparsity of the problem using numerical differentiation methods
    /*! \return void */

    void detectNumericalSparsity();


    //! Obtain the spasity patterns of each of the functions
    /*! \return void */

    void computeBlockPatterns();

    //! Detect the sparsity of the problem using numerical differentiation methods (New Version)
    /*! \return void */

    void computeNumericalSparsity();

    //! Obtain the perturbation matrix for the sparse finite differences algorithm
    /*! \return void */

    void getPerturbationMatrix();

    //! Detect the perturbation groups needed for the sparse finite differences algorithm
    /*! \return void */

    void getIndexGroups();

    //! Obtain the solution from the NLP solver and rearrange it in matrix form, also saves
    //! the values of the states, controls and time solutions along the trajectory
    //!  \return void */

    void getSolution();

    //! Solve the optimal control problem using local collocation methods
    //! \return Status of the solver ('1' if success, '0' if not) */
    int solve();

    //! Evaluate the absolute local error of the solution
    //! \return void */
    void evaluateMeshError();

    //! Evaluate the relative local errors along each segments of the solution
    //! \return void */
    void evaluateSolution();

    //! Estimate the primary order of the new mesh (either Trapezoidal or Hermite-Simpson)
    //! \return void */
    void estimatePrimaryOrder();

    //! Estimate the order reduction of the new mesh
    //! \return void */
    void estimateOrderReduction();

    //! Construct the new mesh given the refinement data
    //! \return void */
    void constructNewMesh();

    //! Detect if the local error is equidistributed along the solution
    //! \return 'true' if is equidistributed, 'false' otherwise
    bool isEquidistributed();

    //!Compute the segmental error between the solution and the real dynamics of the system
    //! \return Value of the absolute error in time t
    double errorFcn(int &nx, double &t);

    //!Compute the segmental error between the solution and the real dynamics of the system
    //! \return Vector with the value of the error |xdot-f(x,u,p,t)|
    Eigen::VectorXd errorFcnSimpson(double &t);

    //!Evaluate the integral of the error using the Romberg quadrature
    //! \return Numerical value of the integral of the error

    double integralError(double &a,double &b, int &ki);

    //!Evaluate the integral of the error |xdot-f(x,u,p,t)| using the Composite Simpson Integration
    //! \return Value of the error integral between tk and tk1

    Eigen::VectorXd integralErrorSimpson(double &tk, double &tk1);

    //!Solve the non linear programming problem using the IPOPT solver
    //! \return Status of the optimization process

    int solveNLP_ipopt();

    //! Construct the new mesh (DirCol5i method)
    //! \return void

    void constructMesh();

    //! Evaluate the solution (DirCol5i method)
    //! \return void

    void evalNLPSolution();

    ~localCollocation(){};


};


}//End nocs namespace






#endif
